/*
 * ADAPTED FROM
 *
 * libjdkmidi-2004 C++ Class Library for MIDI
 *
 *  Copyright (C) 2004  J.D. Koftinoff Software, Ltd.
 *  www.jdkoftinoff.com
 *  jeffk@jdkoftinoff.com
 *
 *  *** RELEASED UNDER THE GNU GENERAL PUBLIC LICENSE (GPL) April 27, 2004 ***
 *
 *
 * BY NICOLA CASSETTA
 *
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#ifndef _JDKMIDI_SEQUENCER_H
#define _JDKMIDI_SEQUENCER_H

#include "multitrack.h"
#include "matrix.h"
#include "processor.h"
#include "notifier.h"
#include "tick.h"

#include <string>


class MIDISequencer;        // forward declaration



///
/// Stores current MIDI parameters for a sequencer track.
/// It stores track name, program, pitch bend, all control changes values and a matrix with notes on and off.
/// The MIDISequencerState class contains a MIDISequencerTrackState for every MIDI Track, and it take care of
/// updating parameters. You can ask the MIDISequencerTrackState if you want to know actual track parameters,
/// however advanced class AdvancedSequencer allows you to get them without dealing with it, so the use of this
/// class is mainly internal. However, you could subclass it if you want to keep track of other parameters.
///
class MIDISequencerTrackState {
    public:
        /// The constructor.
        /// Initial attributes are program = -1 (undefined),  bender_value = 0, all controls = -1,
        /// track_name = "", all notes off.
                        MIDISequencerTrackState();
        /// The destructor does nothing.
        virtual         ~MIDISequencerTrackState() {}

        // Copy constructor and assignment operator generated by the compiler

        /// Resets default values.
        virtual void    Reset();

        char            program;		    ///< current program change, or -1
        int             bender_value;		///< last seen bender value
        std::string     track_name;	        ///< track name
        bool            notes_are_on;       ///< true if there are notes currently on
        MIDIMatrix      note_matrix;        ///< to keep track of all notes on
        char            control_values[C_ALL_NOTES_OFF];        // NOT unsigned to allow -1 if not changed
                                            ///< array of current control change values
        bool            got_good_track_name;///< internal use
};


///
/// Stores current MIDI general parameters for a MIDISequencer object, embedding a MIDISequencerTrackState for each track.
/// It contains a MIDIMultiTrackIterator, allowing to set a 'now' time: when current time changes (because
/// the sequencer is playing or time is changed by the user) the object keep tracks of current timesig, keysig,
/// tempo(BPM), marker, measure and beat data. Moreover it contains an independent MIDISequencerTrackState
/// for every MIDI Track of the MIDISequencer, and you can examine them for knowing actual track parameters.
/// It inherits from the pure virtual MIDIProcessor: the MIDISequencer sends to it MIDI messages and it
/// processes them remembering actual parameters and notifying changes to the GUI.
/// All methods and attributes are public because they are used by MIDISequencer class; the advanced class
/// AdvancedSequencer allows you to know actual parameters without directly examining them, so the use of this
/// class is mainly internal.
/// However, you could subclass it if you want to keep track of other parameters.
///
class MIDISequencerState : public MIDIProcessor {
// Doesn't inherit from MIDISequencerGUINotifier because notifier and sequencer must be independent objects
// (notifier is used also by the MIDIManager)
// All is public: used by various classes
    public:
        /// The constructor is called by the MIDISequencer class constructor, which sets appropriate
        /// values for parameters.
                                MIDISequencerState(MIDIMultiTrack *multitrack_,
                                                   MIDISequencerGUINotifier *n = 0);
        /// The copy constructor. \note This only copies the pointers to the sequencer and the notifier,
        /// so you can use it only if you are copying different states of the same MIDISequencer
        /// class instance.
                                MIDISequencerState(const MIDISequencerState &s);
        /// The destructor. The sequencer and notifier pointers are not owned by the class and they
        /// won't freed.
        virtual                 ~MIDISequencerState();
        /// The assignment operator. See the note to the copy constructor.
        const MIDISequencerState& operator= (const MIDISequencerState &s);

        /// Resets the state to default values. These are: cur_clock = 0, tempo = 120 bpm,
        /// time = 4/4, keysig = C Maj, no marker. Moreover resets all track states (see
        /// MIDISequencerTrackState::Reset()).
        void                    Reset();
        /// This is the process function inherited from MIDIProcessor. When you get a MIDI message
        /// from the sequencer, it is processed by the state, which updates its parameters and
        /// notifies the GUI if required.
        bool                    Process( MIDITimedMessage* msg );

        /// These are used for notifying the GUI when something happens (a parameter was changed,
        /// current time is moved, etc.)
        ///<{
        void                    Notify(int group, int item = 0) const;
        void                    NotifyTrack(int item) const;
        ///<}

        MIDISequencerGUINotifier* notifier;         ///< The notifier
        MIDIMultiTrack*         multitrack;         ///< The MIDIMultiTrack holding MIDI messages
        MIDIMultiTrackIterator  iterator;           ///< The iterator for moving along the multitrack

        MIDIClockTime           cur_clock;          ///< The current MIDI clock in MIDI ticks
        float                   cur_time_ms;        ///< The current clock in milliseconds
        unsigned int            cur_beat;           ///< The current beat in the measure (1st beat is 0)
        unsigned int            cur_measure;        ///< The current measure (1st measure is 0)
        MIDIClockTime           beat_length;        ///< The duration of a beat
        MIDIClockTime           next_beat_time;     ///< The MIDI time of the next beat (for internal use)

        float                   tempobpm;           ///< The current tempo in beats per minute
        char                    timesig_numerator;  ///< The numerator of current time signature
        char                    timesig_denominator;///< The denominator of current time signature
        char                    keysig_sharpflat;   ///< The current key signature accidents (
        char                    keysig_mode;        ///< Major mode (0) or minor (1)
        std::string             marker_text;        ///< The current marker
        std::vector<MIDISequencerTrackState*>
                                track_states;       ///< A track state for every track
        int                     last_event_track;   ///< Internal use
        MIDIClockTime           last_beat_time;     ///< Internal use
        static int              metronome_mode;     ///< Flag affecting how metronome beat is calculated
};


///
/// A MIDITickComponent which implements a basic sequencer, able to play the MIDI events contained in a MIDIMultiTrack.
/// It embeds:
/// - a MIDIMultiTrack for storing MIDI messages
/// - a MIDIMultiTrackIterator, allowing to set a 'now' time, moving it along (manually or by playing)
/// - an (optional) MIDISequencerGUINotifier, that notifies the GUI about MIDI events when they happen
/// - a MIDISequencerState which keeps track of actual sequencer status (tempo, keysig, track parameters, etc.).
///
/// If you want to play events contained in the multitrack you must add your instance to the MIDIManager queue of
/// MIDITickComponent objects with the MIDIManager::AddMIDITick() method, then you can call Start() (aliased by Play())
/// and Stop() to start and stop a separate thread which takes care of playing. All methods are thread safe and can be
/// called during playback.
/// Moreover the class allows the user to:
/// - assign a separate MIDI out port for each track
/// - assign a separate time shift amount (positive or negative) in MIDI ticks for every track
/// - set a separate MIDIProcessor for each track
/// - stretch the global tempo by a percentage (lesser or greater than 100)
/// - set a repeat play loop between two measures
///
/// \note This class is especially suitable for subclassing but has limited playing capacity (for example, if you jump
/// from a time to another it updates the track parameters but doesn't send the appropriate MIDI messages to the drivers).
/// The AdvancedSequencer class is an enhanced sequencer with more features and more easy use.
///
class MIDISequencer : public MIDITickComponent {
    public:
        /// \name Constructors, destructor and reset
        ///@{

        /// The constructor.
        /// \param m a pointer to a MIDIMultiTrack that will hold MIDI messages
        /// \param n a pointer to a MIDISequencerGUINotifier. If you leave 0 the sequencer will not notify
        /// the GUI.
                                        MIDISequencer(MIDIMultiTrack* m, MIDISequencerGUINotifier* n = 0);
        /// The destructor. The MIDIMultiTrack and the MIDISequencerGUINotifier are not owned by the MIDISequencer;
        /// the MIDIProcessor objects, instead, (if you have set them with SetProcessor()) are deleted.
        virtual                         ~MIDISequencer();
        /// Resets the MIDISequencer to its initial state. Moves the time to 0 updating the state (see
        /// MIDISequencerState::Reset()), deletes all the track processors (if you have set them with SetProcessor()),
        /// sets all the tracks to MIDI out 0 and no time offset, sets tempo scale to 100.
        /// \note This doesn't affect the multitrack content. If you want to empty it call GetMultiTrack()->Clear()
        /// **before** this (so the sequencer state is correctly updated).
        /// You should call this when the multitrack contents are changed (adding or deleting tracks) to reinitialize
        /// the MIDISequencer according to the new contents.
        void                            Reset();
        ///@}

        /// \name The get methods
        ///@{

        /// Returns current MIDIClockTime in MIDI ticks; it is effective even during playback
        MIDIClockTime                   GetCurrentMIDIClockTime() const;
        /// Returns current time in milliseconds; it is effective even during playback
        float                           GetCurrentTimeMs() const;
        /// Returns current measure (1st measure is 0).
        unsigned int                    GetCurrentMeasure() const
                                                                { return state.cur_measure; }
        /// Returns current beat in the measure (1st beat is 0).
        unsigned int                    GetCurrentBeat() const  { return state.cur_beat; }
        /// Returns the current MIDI time offset respect to current beat.
        MIDIClockTime                   GetCurrentBeatOffset() const
                                                                { return state.cur_clock - state.last_beat_time; }
        /// Returns the base MIDI ticks per beat ratio of the internal MIDIMultiTrack. Default value is 120 clocks per
        /// quarter beat. However, loading a MIDIFile into the MIDIMultiTrack can change this according to the file
        /// clock.
        int                             GetClksPerBeat() const  { return state.multitrack->GetClksPerBeat(); }

        /// Returns a pointer to the internal MIDIMultiTrack.
        MIDIMultiTrack*                 GetMultiTrack()         { return state.multitrack; }
        /// Returns a pointer to the internal MIDIMultiTrack.
        const MIDIMultiTrack*           GetMultiTrack() const   { return state.multitrack; }
        /// Returns the number of tracks of the multitrack.
        unsigned int                    GetNumTracks() const	{ return state.multitrack->GetNumTracks(); }
        /// Returns current tempo scale in percentage (100 = no scaling, 200 = twice faster, etc.).
        unsigned int                    GetTempoScale() const   { return tempo_scale; }
        /// Returns current tempo (BPM) without scaling.
        float                           GetTempoWithoutScale() const
                                                                { return state.tempobpm; }
        /// Returns current tempo (BPM) taking into account scaling (this is the true actual tempo).
        float                           GetTempoWithScale() const
                                                                { return state.tempobpm * tempo_scale * 0.01; }
        /// Returns the repeat play (loop) status on/off.
        bool                            GetRepeatPlay() const   { return repeat_play_mode; }
        /// Returns the repeat play (loop) start measure.
        unsigned int                    GetRepeatPlayStart() const
                                                                { return repeat_start_meas; }
        /// Returns the repeat play (loop) end measure.
        unsigned int                    GetRepeatPlayEnd() const
                                                                { return repeat_end_meas; }
        /// Returns a pointer to the current MIDISequencerState (i.e\. the global sequencer state at
        /// current time). You can easily jump from a time to another saving and retrieving sequencer states.
        MIDISequencerState*             GetState()              { return &state; }
        /// Returns a pointer to the current MIDISequencerState (i.e\. the global sequencer state at
        /// current time). You can easily jump from a time to another saving and retrieving sequencer states.
        const MIDISequencerState*       GetState() const        { return &state; }
        /// Returns a pointer to the MIDISequencerTrackState for a track.
        /// \param trk the track number
        MIDISequencerTrackState*        GetTrackState(unsigned int trk)
                                                                { return state.track_states[trk]; }
        /// Returns a pointer to the MIDISequencerTrackState for a track.
        /// \param trk the track number
        const MIDISequencerTrackState*  GetTrackState(unsigned int trk) const
                                                                { return state.track_states[trk]; }
        /// Returns a pointer to the MIDISequencerTrackProcessor for a track.
        /// \param trk the track number
        /// \return the processor pointer (if you have already set it with the SetProcessor() method),
        /// otherwise 0
        MIDIProcessor*                  GetTrackProcessor(unsigned int trk)
                                                                { return track_processors[trk]; }
        /// Returns a pointer to the MIDISequencerTrackProcessor for a track.
        /// \param trk the track number
        /// \return the processor pointer (if you have already set it with the SetProcessor() method),
        /// otherwise 0
        const MIDIProcessor*            GetTrackProcessor(unsigned int trk) const
                                                                { return track_processors[trk]; }
        /// Returns the time offset (in MIDI ticks) assigned to a track.
        /// \see SetTimeOffset(), SetTimeOffsetMode().
        /// \param trk the track number
        int                             GetTrackTimeShift(unsigned int trk) const
                                                                { return time_shifts[trk]; }
        /// Return the number of the port assigned to a track.
        /// \param trk the track number
        unsigned int                    GetTrackPort(unsigned int trk) const
                                                                { return track_ports[trk]; }
        ///@}

        /// \name The set methods
        ///@{

        /// Sets the repeat play (loop) parameters: you can set the repeat play status on/off, the start and the
        /// end measure.
        /// When the repeat play mode is on, the sequencer will start playing from its current position if it is
        /// before the end measure, or from the start measure otherwise. When it reaches the end of the loop it
        /// jumps to the start.
        /// \param on_off can be 0 (repeat play off), 1 (repeat play on) or -1 (leave the state unchanged). The
        /// latter can be useful if you only want to change the start or stop measure
        /// \param start_meas, end_meas you can set the start and end measures (remember that measure numbers start
        /// with 0). If you set an end measure lesser or equal to the start the loop is automatically disabled. If
        /// you leave the default values the measures are left unchanged (useful if you only want to turn on or off the
        /// loop).
        void                            SetRepeatPlay(int on_off, int start_meas = -1, int end_meas = -1);
        /// Sets the global tempo scale.
        /// \param scale the percentage: 100 = no scaling, 200 = twice faster, 50 = twice slower, etc.).
        void                            SetTempoScale(unsigned int scale);
        /// Sets the time shift offset (in MIDI ticks) for a track. The offset can be positive or negative; events
        /// shifted include all channel messages and sysex messages (others remain at their time).
        /// If you select a negative offset, be sure not to have shifted events at lesser time than the offset
        /// (they won't be shifted). This method is thread-safe and can be called during playback.
        /// \see SetTimeOffsetMode().
        /// \param trk the track number
        /// \param offset the offset in MIDI ticks
        void                            SetTrackTimeShift(unsigned int trk, int offset);
        /// Sets the MIDI port for a track. This method is thread-safe and can be called during playback (in this
        /// case the sequencer will send a MIDI AllNotesOff message to the old port).
        /// \param trk the track number
        /// \param port the id number of the port (see MIDIManager::GetOutPorts())
        void                            SetTrackOutPort(unsigned int trk, unsigned int port);
        /// Copies a given MIDISequencerState into the internal sequencer state. This method is thread-safe and
        /// can be called during playback. Notifies the GUI a GROUP_ALL event to signify a full GUI reset.
        /// \param s a pointer to the new state.
        /// \note  You can save and restore the sequencer states for quickly jumping from a time to another;
        /// however you should avoid to save a state, edit the multitrack events and then restore the old state,
        /// because you can get inconsistent state parameters.
        void                            SetState(MIDISequencerState* s);
        /// Sets a MIDIProcessor for a track. This can't be done while the sequencer is playing so it stops it.
        /// \note the Reset() methods deletes all processors if you have set it
        void                            SetProcessor(unsigned int trk, MIDIProcessor * p);
        ///@}

        /// \name Other methods
        ///@{

        /// Inserts into the internal MIDIMultiTrack a new empty track with default track parameters (transpose,
        /// time offset, etc.). This method is thread-safe and can be called during playback. Notifies the GUI a
        /// GROUP_ALL event to signify a full GUI reset.
        /// \param trk the track number (it must be in the range 0 ... GetNumTracks() - 1). If you leave the default
        /// value the track will be appended as last.
        /// \return *true* if the track was effectively inserted
        /// \note You shouldn't use the corresponding method of MIDIMultiTrack class, as it doesn't sync the
        /// iterator and the sequencer internal arrays. If you change the number of tracks directly in the
        /// multitrack (for example when loading a MIDI file) you must then call MIDISequencer::Reset() for
        /// updating the sequencer, but this will reset all track parameters to the default.
        bool                            InsertTrack(int trk = -1);
        /// Deletes a track and all its events from the internal MIDIMultiTrack. This method is thread-safe and can
        /// be called during playback (in this case the sequencer will send a MIDI AllNotesOff message to the old track
        /// port). Notifies the GUI a GROUP_ALL event to signify a full GUI reset.
        /// \param trk the track number (must be in the range 0 ... GetNumTracks() - 1).
        /// \return *true* if the track was effectively deleted
        /// \see note to InsertTrack()
        bool                            DeleteTrack(int trk);
        /// Moves a track from one position to another in the internal MIDIMultiTrack. This method is thread-safe and can
        /// be called during playback (in this case the sequencer will send a MIDI AllNotesOff message to the involved
        /// ports). Notifies the GUI a GROUP_ALL event to signify a full GUI reset.
        /// \param from, to the start and destination track numbers (both must be in the range 0 ... GetNumTracks() - 1).
        /// \return *true* if the track was effectively moved
        /// \see note to InsertTrack()
        bool                            MoveTrack(int from, int to);
        /// Sets the current time to the beginning of the song, updating the internal status. This method is
        /// thread-safe and can be called during playback. Notifies the GUI a GROUP_ALL event to signify a
        /// full GUI reset.
        void                            GoToZero();
        /// Sets the current time to a given the MIDI time, updating the internal status. This method is thread-safe
        /// and can be called during playback. Notifies the GUI a GROUP_ALL event to signify a full GUI reset
        /// \param time_clk the new time in MIDI ticks
        /// \return _true_ if the new time is effectively reached, _false_ otherwise (time_clk is after
        /// the end of the song)
        bool                            GoToTime (MIDIClockTime time_clk);
        /// Same as GoToTime(), but the time is given in milliseconds.
        bool                            GoToTimeMs (float time_ms);
        /// Sets the current time to the given measure and beat, updating the internal status.
        /// Notifies the GUI a GROUP_ALL event to signify a GUI reset
        /// \return see GoToTime()
        bool                            GoToMeasure (unsigned int measure, unsigned int beat = 0);
        /// Gets the next event (respect current position). This queries the state for the next event in the
        /// multitrack, then processes it with the corresponding track processor (if you have set it with
        /// SetProcessor)) and updates the state. Moreover it notifies the GUI with appropriate messages. If
        /// there are no events before the next metronome click you will get a Beat Marker internal event.
        /// \param[out] trk will return the track of the next event
        /// \param[out] msg will return the MIDI event
        /// \return _true_ if there is effectively a next event (and the parameters are valid), _false_ otherwise
        /// (parameters are undefined)
        bool                            GetNextEvent (int *trk, MIDITimedMessage *msg);
        /// Gets the time of the next event (it can be different from current time if at current time there
        /// are not events).
        /// \param[out] time_clk: will return the requested time in MIDI ticks from the beginning
        /// \return _true_ if there is effectively a next event (and *t is a valid time) _false_ if we are at
        /// the end of the song (*t is undefined)
        bool                            GetNextEventTime (MIDIClockTime *time_clk);
        /// Same of GetNextEventTime(), but time is returned in milliseconds from the beginning.
        bool                            GetNextEventTimeMs (float *time_ms);
        /// Converts a time from MIDI ticks into milliseconds, taking into account all tempo changes from the
        /// beginning of the song to the given time.
        /// \param time_clk the time to convert
        float                           MIDItoMs(MIDIClockTime time_clk);  // new : added by me
        /// This is equivalent of GoToTime(state.cur_time) and should be used to update the sequencer
        /// state after an edit in the multitrack (adding, deleting or editing events, for changes in the track
        /// structure see InsertTrack(), DeleteTrack() and MoveTRack()). If you have edited the multitrack, call
        /// this before moving time, getting events or playing.
        void                            UpdateStatus()  { GoToTime(state.cur_clock); }
        /// Sets the time shifting of events on and off. If you are editing the multitrack events you probably
        /// want to see the original (not shifted) MIDI time of events, while during playback you want them
        /// shifted. So you can turn time shifting on and off (and all the time related methods of the sequencer
        /// will return the shifted or the original time of events). The Start() method sets time shifting on,
        /// while the Stop() sets it off, so usually you have no need to use this function.
        void                            SetTimeShiftMode(bool f)
                                                        { state.iterator.GetState().SetTimeShiftMode(f); }
        // Inherited from MIDITICK
        /// Starts the sequencer playing from the current time.
        virtual void Start();
        /// Stops the sequencer playing.
        virtual void Stop();
        /// This is an alias of Start().
        virtual void Play()         { Start(); }
        ///@}

        /// Values for the SetMetronomeMode() method.
        enum {
            FOLLOW_MIDI_TIMESIG_MESSAGE,    ///< follow the value stored in the last seen MIDI TimeSig message
            FOLLOW_TIMESIG_DENOMINATOR,     ///< follow the denominator of the time signature
            FOLLOW_THEORETIC_VALUE          ///< follow the music theory value
        };

        /// Selects the way the sequencer calculates metronome beat. You have three choices:
        /// - FOLLOW_MIDI_TIMESIG_MESSAGE  the sequencer uses as metronome beat the value stored in the last seen
        ///   MIDI TimeSig message
        /// - FOLLOW_TIMESIG_DENOMINATOR   the sequencer uses as metronome beat the denominator of the time
        ///   signature (so 4/4 => quarter note, 6/8 -> eighth note etc.)
        /// - FOLLOW_THEORETICAL_VALUE     the sequencer uses as metronome beat the music theory value, taking into
        ///   account simple and composite time signatures (so 4/4 => quarter note, 6/8 => dotted quarter note, etc.)
        ///
        /// Don't use this while the sequencer is playing.
        static void                     SetMetronomeMode(int mode)
                                                        { MIDISequencerState::metronome_mode = mode; }

    protected:
        // Inherited from MIDITICK
        static void                     StaticTickProc(tMsecs sys_time, void* pt);
        virtual void                    TickProc(tMsecs sys_time);

        static void                     StaticStopProc(MIDISequencer* p)    { p->Stop();}

        /// Internal use: scans events at 'now' time upgrading the sequencer state
        void                            ScanEventsAtThisTime();

        MIDITimedMessage                beat_marker_msg;    ///< Used by the sequencer to send beat marker messages

        unsigned int                    tempo_scale;        ///< The tempo scale in percentage (100 = true time)
        bool                            repeat_play_mode;   ///< Enables the repeat play mode
        unsigned int                    repeat_start_meas;  ///< The loop start measure
        unsigned int                    repeat_end_meas;    ///< The loop end measure

        std::vector<MIDIProcessor*>     track_processors;   ///< A MIDIProcessor for every track
        std::vector<int>                time_shifts;        ///< A time shift (in MIDI ticks) for every track
        std::vector<unsigned int>       track_ports;        ///< The port id for every track
        MIDISequencerState              state;              ///< The sequencer state
};


#endif





/*
 *  libjdksmidi-2004 C++ Class Library for MIDI
 *
 *  Copyright (C) 2004  J.D. Koftinoff Software, Ltd.
 *  www.jdkoftinoff.com
 *  jeffk@jdkoftinoff.com
 *
 *  *** RELEASED UNDER THE GNU GENERAL PUBLIC LICENSE (GPL) April 27, 2004 ***
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
//
// Copyright (C) 2010 V.R.Madgazin
// www.vmgames.com vrm@vmgames.com
//

//
// MODIFIED by N. Cassetta  ncassetta@tiscali.it
// search /* NC */ for modifies
//




/*
#ifndef JDKSMIDI_SEQUENCER_H
#define JDKSMIDI_SEQUENCER_H

namespace jdksmidi
{


///
/// This class stores current MIDI general parameters.
/// It contains a MIDIMultiTrackIterator, allowing to set a 'now' time: when the current time changes (because
/// the sequencer is playing or it is moved by the user) the class stores current timesig, keysig, tempo(BPM),
/// marker, measure and beat data. Furthermore it inherits from the pure virtual MIDIProcessor:
/// the MIDISequencer sends to it MIDI messages and it processes them  remembering actual parameters and
/// notifying chamges to the GUI.
/// This class contains an independent MIDISequencerTrackState for every MIDI Track and you can
/// ask it for knowing actual parameters. However, advanced class AdvancedSequencer allows you to know them
/// without dealing with this, so the use of this class is mainly internal.
/// However, you could subclass it if you want to keep track of other parameters.
///

class MIDISequencerState : public MIDIProcessor
{
public:

    /// The constructor sets sequencer current time to 0. It allocates memory to hold a MIDISequencerTrackState
    /// for every track. Parameters are not owned.
    MIDISequencerState ( const MIDISequencer *s,
                         const MIDIMultiTrack *multitrack_,
                         MIDISequencerGUINotifier *n );

    /// The copy constructor
    MIDISequencerState ( const MIDISequencerState &s );

    /// The destructor frees allocated memory
    ~MIDISequencerState();

    /// The equal operator
    const MIDISequencerState & operator = ( const MIDISequencerState &s );

    /// Resets the state to current time = 0.
    void Reset();                                          // new

    /// Processes the message msg: if it is a channel message (or a track name meta) send it to a
    /// MIDISequencerTrackState, otherwise notify the GUI directly
    bool Process(MIDITimedMessage* msg);                   // new

    /// Notifies events to GUI
    void Notify( int group, int item = 0 );                // new

    MIDISequencerGUINotifier *notifier;
    const MIDISequencer* seq;                              // for notifying
    const MIDIMultiTrack *multitrack;
    int num_tracks;                                 ///< nunber of tracks of the sequencer

    MIDISequencerTrackState *track_state[64];
    MIDIMultiTrackIterator iterator;
    MIDIClockTime cur_clock;                        ///< current time MIDI clock
    float cur_time_ms;                              ///< current time in ms
    int cur_beat;                                   ///< current beat
    int cur_measure;                                ///< current measure
    MIDIClockTime last_beat_time;   /* NC           ///< used internally by Process()
    MIDIClockTime next_beat_time;                   ///< used internally by Process()
    float tempobpm;                                 ///< current tempo in beats per minute
    char timesig_numerator;                         ///< numerator of current time signature
    char timesig_denominator;                       ///< denominator of current time signature
    char keysig_sharpflat;                          ///< current key signature accidentals
    char keysig_mode;                               ///< major/minor mode
    char marker_name[40];                           ///< current marker name
    int last_event_track;                           ///< used internally by Process()
};


///
/// This class implements a complete sequencer. This class holds:
/// - a MIDIMultiTrack for storing MIDI messages
/// - a MIDISequencerTrackProcessor for every track, allowing muting, soloing, transposing, ecc.
/// - a MIDIMultiTrackIterator, allowing to set a 'now' time, moving it along
/// - a MIDISequencerGUIEventNotifier, that notifies the GUI about MIDI events
/// - a MIDISequencerState (which embeds the multitrack, the iterator and the notifier) to keep track
/// of actual parameters (tempo, keysig, track parameters, etc.)
/// \note This class has no playing capacity. For playing MIDI content you must use it together with a
/// MIDIManager. See the example files for effective using. AdvancedSequencer is an all-in-one class for
/// sequencing and playing
///
class MIDISequencer {
    public:

            /// The constructor.
            /// \param m a pointer to a MIDIMultitrack that will hold MIDI messages
            /// \param n a pointer to a MIDISequencerGUIEventNotifier. If you leave 0 the sequencer
            /// will not notify the GUI.
                                        MIDISequencer (const MIDIMultiTrack *m, MIDISequencerGUINotifier *n = 0);
            /// The destructor frees allocated memory. The MIDIMultiTrack and the MIDISequencerGUINotifier
            /// are not owned by the MIDISequencer
        virtual                         ~MIDISequencer();

            /// Resets the corresponding MIDISequencerTrackState and MIDISequencerTrackProcessor.
            /// See MIDISequencerTrackState::Reset() and MIDISequencerTrackProcessor::Reset()
        void                            ResetTrack (int trk);

        /// Call ResetTrack() for all tracks
        void                            ResetAllTracks();

        /// Returns current MIDIClockTime
        MIDIClockTime                   GetCurrentMIDIClockTime() const     { return state.cur_clock; }

        /// Returns current time in milliseconds
        float                           GetCurrentTimeInMs() const          { return state.cur_time_ms; }

        /// Returns current beat
        int                             GetCurrentBeat() const              { return state.cur_beat; }

    /// Returns current measure
    int GetCurrentMeasure() const
    {
        return state.cur_measure;
    }

    /// Returns curremt tempo scale (1.00 = no scaling, 2.00 = twice faster, etc.)
    double GetCurrentTempoScale() const
    {
        return ( ( double ) tempo_scale ) * 0.01;
    }

    ///< Returns current tempo (BPM) without scaling ( actual tempo is GetCurrentTempo() * GetCurrentTempoScale() )
    double GetCurrentTempo() const
    {
        return state.tempobpm;
    }

    /// Returns current MIDISequencerState (i.e. the global sequencer state at current time). You can easily
    /// jump from a time to another saving and retrieving sequencer states.
    MIDISequencerState *GetState()
    {
        return &state;
    }

    const MIDISequencerState *GetState() const
    {
        return &state;
    }

    /// Returns the MIDISequencerTrackState for track trk
    MIDISequencerTrackState * GetTrackState ( int trk )
    {
        return state.track_state[trk];
    }

    const MIDISequencerTrackState * GetTrackState ( int trk ) const
    {
        return state.track_state[trk];
    }

    /// Returns the MIDISequencerTrackProcessor for track trk
    MIDISequencerTrackProcessor * GetTrackProcessor ( int trk )
    {
        return track_processors[trk];
    }

    const MIDISequencerTrackProcessor * GetTrackProcessor ( int trk ) const
    {
        return track_processors[trk];
    }

    /// Returns the number of tracks of the MIDIMultiTrack
    int GetNumTracks() const
    {
        return state.num_tracks;
    }

    /// Returns the solo mode on/off
    bool GetSoloMode() const
    {
        return solo_mode;
    }

    /// Copies the MIDISequencerState s into the internal sequencer state. You can easily
    /// jump from a time to another saving and retrieving sequencer states.
    void SetState ( MIDISequencerState *s )
    {
        state = *s;
    }

    /// Sets the tempo scale (1.00 = no scaling, 2.00 = twice faster, etc)
    void SetCurrentTempoScale ( float scale )
    {
        tempo_scale = ( int ) ( scale * 100 );
    }

    /// Soloes/unsoloes a track
    /// \param m on/off
    /// \param trk the nunber of the track if m is true, otherwhise you can leave default value
    void SetSoloMode ( bool m, int trk = -1 );

    /// Sets the 'now' time to the beginning of the song, upgrading the internal status.
    /// Notifies the GUI a GROUP_ALL notifier event to signify a GUI reset
    void GoToZero();

    /// Sets the 'now' time to the MIDI time time_clk, upgrading the internal status.
    /// Notifies the GUI a GROUP_ALL notifier event to signify a GUI reset
    /// \return _true_ if the time time_clk is effectively reached, _false_ otherwise (if time_clk is after
    /// the end of the song)
    bool GoToTime ( MIDIClockTime time_clk );

    /// Same as GoToTime(), but the time is given in milliseconds
    bool GoToTimeMs ( float time_ms );

    /// Sets the 'now' time to the given measure and beat, upgrading the internal status.
    /// \return see GoToTime()
    bool GoToMeasure ( int measure, int beat = 0 );


    bool GetNextEventTimeMs ( float *t );
    bool GetNextEventTimeMs ( double *t );

    /// Get the time of the next event (respect to the 'now' time) in MIDI ticks
    /// \return _true_ if there is a next event (and *t is a valid time) _false_ otherwise (*t is undefined)
    bool GetNextEventTime ( MIDIClockTime *t );

    /// Get the next event respect to the 'now' time.
    /// \param[out] tracknum: the track of the next event
    /// \param[out] msg the MIDI event
    /// \return _true_ if there is a next event (and the paraneters are valid), _false_ otherwise (parameters undefined)
    bool GetNextEvent ( int *tracknum, MIDITimedMessage *msg );



protected:

    /// Internal use: scans events at 'now' time upgrading the sequencer status
    void ScanEventsAtThisTime();

    MIDITimedMessage beat_marker_msg;

    bool solo_mode;
    int tempo_scale;

    int num_tracks;
    MIDISequencerTrackProcessor *track_processors[64];

    MIDISequencerState state;
} ;
}


#endif
*/
