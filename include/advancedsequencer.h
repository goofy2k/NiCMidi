/* Some code Copyright 1986 to 1998 By J.D. Koftinoff Software, Ltd.
 *
*/


/// \file
/// Contains the definition of the classes MIDISequencerTrackProcessor and AdvancedSequencer.


#ifndef _JDKMIDI_ADVANCEDSEQUENCER_H
#define _JDKMIDI_ADVANCEDSEQUENCER_H

#include <vector>
#include <string>

#include "msg.h"
#include "driver.h"
#include "thru.h"
#include "multitrack.h"
#include "sequencer.h"
#include "manager.h"
#include "smpte.h"


///
/// A multipurpose MIDIProcessor implementing muting, soloing, rechannelizing, velocity scaling and transposing.
/// Moreover, you can set a custom MIDIProcessor pointer which extra-processes messages.
/// The AdvancedSequencer class contains an independent MIDISequencerTrackProcessor for every MIDI Track,
/// and allow you to set muting, transposing etc. by dedicated methods without directly dealing with this:
/// the only useful function for the user is probably the extra processing hook.
/// However, you could subclass this if you want to get new features.
///
class MIDISequencerTrackProcessor : public MIDIProcessor {
    public:
        /// The constructor. Default is no processing (MIDI messages leave the processor unchanged).
                        MIDISequencerTrackProcessor();
        /// The destructor does nothing.
        virtual         ~MIDISequencerTrackProcessor() {}

        // Copy constructor and assignment operator generated by the compiler

        /// Resets all values to default state (no processing at all).
        virtual void    Reset();
        /// Sets the extra processor for the track. The user processing is done before all internal
        /// processing, and if the user Process() function returns _false_ it is not done at all.
        /// If you want to eliminate an already set processor call this with 0 as parameter
        void            SetExternalProcessor(MIDIProcessor* proc)
                                                { extra_proc = proc; }
        /// Processes message msg, changing its parameters according to the state of the processor
        virtual bool    Process ( MIDITimedMessage *msg );

        bool            mute;                   ///< track is muted
        char            solo;                   ///< NO_SOLO, SOLOED, NOT_SOLOED
        int             velocity_scale;         ///< current velocity scale value for note ons, 100=normal
        int             rechannel;              ///< rechannelization value, or -1 for none
        int             transpose;              ///< amount to transpose note values
        MIDIProcessor   *extra_proc;            ///< extra midi processing for this track

        enum { NO_SOLO, SOLOED, NOT_SOLOED };
};


///
/// An enhanced MIDISequencer, able to directly load and play MIDI files and many more.
/// These are the improvements:
/// + There is no need to manually add it to the MIDIManager queue (the constructor does it)
/// + Has methods for loading/unloading a MIDI file into the internal MIDIMultiTrack
/// + Embeds a MIDIThru component with processors for rechannelizing and transposing incoming messages, so
///   you can play your keyboard while the sequencer is playing
/// + Embeds a MIDISequencerTrackProcessor for each track, allowing to transpose, rechannelize, scale velocity
///   solo and mute the tracks
/// + Has improved methods for jumping from a time to another: if you start the sequencer from the middle of a
///   song it automatically sets appropriate MIDI controls, patches and sysex
///
class AdvancedSequencer : public MIDISequencer {
    public:
        /// \name Constructors, destructor and reset
        ///@{


        /// Creates an AdvancedSequencer with 17 tracks (one for each channel plus the master track). Adds the
        /// sequencer to the MIDIManager queue of tick components, so you can immediately start to edit the
        /// MIDIMultiTrack or load MIDI files and play.
        /// \note If you create the object with this constructor the Internal multitrack is owned by the
        /// sequencer and will be deleted when you destroy it.
                            AdvancedSequencer(MIDISequencerGUINotifier *n = 0);
        /// Creates an AdvancedSequencer from a given MIDIMultiTrack. Adds the sequencer to the MIDIManager queue
        /// of tick components, so you can immediately start to play.
        /// \note If you create the object with this constructor the Internal multitrack is **not** owned by the
        /// sequencer and won't be deleted when you destroy it.
                            AdvancedSequencer(MIDIMultiTrack* mlt, MIDISequencerGUINotifier *n = 0);
        /// The destructor.
        virtual             ~AdvancedSequencer();

        /// Resets the status of the sequencer (doesn't empty the MIDIMultiTrack).
        /// Use this if you have modified the MIDIMultiTrack adding, moving or deleting tracks; this
        /// moves the time to 0 and resets all the processors.
        void                Reset();

        /// Loads a MIDIFile into the internal MIDIMultiTrack. It can change the multitrack clks_per_beat parameter
        /// according to the file signature. You can then play the MIDI content with the Play() method.
        /// \param fname the file name.
        bool                Load(const char *fname);
        /// Copies the content of an external MIDIMultiTrack into the sequencer. It can change the multitrack
        /// clks_per_beat parameter according to the multitrack signature. You can then play the MIDI content with
        /// the Play() method.
        /// \param tracks the MIDIMultiTrack to be copied.
        bool                Load(const MIDIMultiTrack* tracks);
        /// Clears the contents of the internal MIDIMultiTrack and reset its clks_per_beat parameter to DEFAULT_CLKS_PER_BEAT
        /// (actually 120).
        void                UnLoad();
        ///@}

        /// \name The get methods
        ///@{

        /// Returns **true** if the internal MIDIMultiTrack is not empty.
        bool                IsLoaded() const                { return file_loaded; }
        /// Returns the address of the MIDIThru tick component.
        const MIDIThru*     GetMIDIThru() const             { return &thru; }
        /// Returns **true** if MIDI thru is enabled.
        bool                GetMIDIThruEnable() const       { return thru.IsPlaying(); }
        /// Returns the output channel of the MIDIThru tick component.
        int                 GetMIDIThruChannel() const      { return thru_rechannelizer.GetRechanMap(0); }
        /// Returns the transpose amount of the MIDIThru tick component.
        int                 GetMIDIThruTranspose() const    { return thru_transposer.GetChannelTranspose(0); }
        /// Returns **true** if any track is soloed.
        bool                GetSoloMode() const;
        /// Returns **true** if a specific track is soloed
        /// \param trk the number of the track
        bool                GetTrackSolo(unsigned int trk) const
                                                            { return (((MIDISequencerTrackProcessor *)track_processors[trk])->solo ==
                                                                       MIDISequencerTrackProcessor::SOLOED); }
         /// Returns **true** if a specific track is muted
        /// \param trk the number of the track
        bool                GetTrackMute (unsigned int trk) const
                                                            { return ((MIDISequencerTrackProcessor *)track_processors[trk])->mute; }
        /// Returns the number of measures of the sequencer.
        int                 GetNumMeasures() const          { return num_measures; }
        /// Returns the current measure number (first is 0).
        unsigned int        GetCurrentMeasure() const;
        /// Returns the number of current beat (first is 0).
        unsigned int        GetCurrentBeat() const;
        /// Returns the current MIDI time offset respect current beat.
        MIDIClockTime       GetCurrentBeatOffset() const;
        /// Returns the numerator of current time signature.
        int                 GetTimeSigNumerator() const;
        /// Returns the denominator of current time signature.
        int                 GetTimeSigDenominator() const;
        /// Return the number of sharps or flats of the current key signature (see MIDIMessage::GetKeySigSharpsFlats()).
        int                 GetKeySigSharpsFlats() const;
        /// Returns the mode (major/minor) of the he current key signature (see MIDIMessage::GetKeySigMode()).
        int                 GetKeySigMode() const;
        /// Returns the current marker text.
        std::string         GetCurrentMarker() const;
        /// Returns the name of the given track.
        std::string         GetTrackName(unsigned int trk) const;
        /// Returns the current MIDI volume for the given track (-1 if volume wasn't set at time 0).
        char                GetTrackVolume(unsigned int trk) const;          // MIDI value or -1
        /// Returns the current MIDI program (patch) for the given track (-1 if the program wasn't set  at time 0).
        char                GetTrackProgram (unsigned int trk) const;      // MIDI value or -1
        /// Returns the number of notes currently sounding on the given track (0 if the sequencer is not playing).
        int                 GetTrackNoteCount(unsigned int trk) const;

        /// Returns the velocity scale percentage for the given track.
        unsigned int        GetTrackVelocityScale(unsigned int trk) const;
        /// Returns the rechannelized channel for the given track (-1 if the track is not rechannelized).
        int                 GetTrackRechannelize(unsigned int trk) const;
        /// If the track has channel messages all with same channel returns the channel, otherwise -1.
        /// \note This is **not** const because it may reanalyze the track setting its status parameter.
        int                 GetTrackChannel(unsigned int trk);   // NOT const!!!
        /// Returns the transposing amount in semitones for the given track.
        int                 GetTrackTranspose(unsigned int trk) const;
        /// Returns the time offset (in MIDI ticks) assigned to the given track.
        int                 GetTrackTimeShift(unsigned int trk) const;
        /// Returns a pointer to the MIDISequencerTrackProcessor for the given track.
        MIDISequencerTrackProcessor*    GetTrackProcessor(unsigned int trk)
                                                            { return (MIDISequencerTrackProcessor *)track_processors[trk]; }
        /// Returns a pointer to the MIDISequencerTrackProcessor for the given track.
        const MIDISequencerTrackProcessor* GetTrackProcessor(unsigned int trk) const
                                                            { return (const MIDISequencerTrackProcessor *)track_processors[trk]; }
        ///@}

        /// \name The set methods
        ///@{

        /// Enables or disables the embedded MIDIthru.
        void                SetMIDIThruEnable(bool on_off);
        /// Sets the out channel for MIDIthru.
        void                SetMIDIThruChannel(int chan);
        /// Sets a transpose amount in semitones for the messages coming from the MIDI thru (see MIDIProcessorTransposer).
        void                SetMIDIThruTranspose (int amt);
        /// Soloes the given track muting all others.
        void                SetTrackSolo(unsigned int trk);
        /// Unsoloes the soloed track unmuting all others.
        void                UnSoloTrack();
        /// Mute/unmute the given track (it has no effect on others).
        void                SetTrackMute(unsigned int trk, bool f);
        /// Unmutes all muted tracks (this has no effect on tracks muted by SoloTrack()).
        void                UnmuteAllTracks();
        /// Sets a track velocity scale in percentage for the given track.
        void                SetTrackVelocityScale(unsigned int trk, unsigned int scale);
        /// Sets a channel for the given track (all chennel messages in it will be output on given channel,
        /// regardless their original channel).
        void                SetTrackRechannelize(unsigned int trk, int chan);
        /// Sets a transpose amount in semitones for the given track (see MIDIProcessorTransposer).
        void                SetTrackTranspose(unsigned int trk, int trans);
        //void                SetTrackTimeShift(unsigned int trk, int offset);
        ///@}

        /// \name Other methods
        ///@{

        void                GoToZero()                      { GoToTime(0); }
        void                GoToMeasure(int measure, int beat = 0);
        void                GoToTime(MIDIClockTime t);

        virtual void        Start();
        virtual void        Stop();
        /// Sends a given MIDI message to an hardware port in a thread safe way (can
        /// be called while playing).
        /// \param msg the MIDI message
        /// \param port the port id
        void                OutputMessage(MIDITimedMessage& msg, unsigned int port);

        //void                SetRepeatPlay(bool on_off, int start_meas, int end_meas);
        //void                SetTempoScale(unsigned int scale);

        /// Sets the parameters of the given SMPTE according to the loaded content. If the loaded
        /// file contains a MIDI SMPTE offset message, sets the parameters according to the offset and
        /// the frame rate of the message, otherwise set it to standard values (offset=0, frame=30FPS)
        void                SetSMPTE(SMPTE* s);

        void                SetChanged();
        ///@}

    protected:

        static const int                    MEASURES_PER_WARP = 4;  ///< The interval between measures in ExtractWarpPositions()

        /// Internal use. It registers the state of the sequencer every MEASURES_PER_WARP measures, and create a
        /// std::vector of MIDISequencerState for a quicker jump from a time to another.
        void                                ExtractWarpPositions();
        /// Internal use. When jumping from a time to another while the sequencer is playing, it examines all events
        /// between old and new time (or between start and new time, if lesser then old), sending to the ports the
        /// appropriate control, program, pitch bend and sysex messages in order to exactly reproduce the sequencer
        /// setting at the new time.
        void                                CatchEventsBefore();
        /// Internal use. As before, but only on the given track (this is useful when a formerly muted track is unmuted,
        /// and needs to be set with appropriate controls, program etc.
        void                                CatchEventsBefore(int trk);
        //void                                InternalStart();
        //void                                InternalStop();

        MIDIThru                            thru;               ///< The embedded MIDI thru

        MIDIMultiProcessor                  thru_processor;     ///< Processes incoming MIDI messages for MIDI thru
        MIDIProcessorTransposer             thru_transposer;    ///< Transposes thru note messages while playing
        MIDIProcessorRechannelizer          thru_rechannelizer;
                                                                ///< Rechannelize thru messages while playing
        int                                 num_measures;       ///< Number of measures
        bool                                file_loaded;        ///< True if the multitrack is not empty

        std::vector<MIDISequencerState>     warp_positions;     ///< Vector of MIDISequencerState objects for fast time moving

        //std::vector<MIDISequencerTrackProcessor*>
        //                                    track_processors;   ///< A MIDISequencerTrackProcessor for every track

    private:

        bool owns_tracks;
};



/*    O L D
///
/// A high level, all-in-one object capable to load an play MIDI files.
/// Its features include:
/// - Loading of MIDI files with a single call to a class method
/// - Play, Repeat Play (i.e. loop) and Stop commands
/// - Allows jumping from one time to another (even during playback) with correct responding
/// to wheel, patch, controls and sysex changes
/// - Individual solo, mute, velocity scale, transpose and rechannelize for every track
/// - Global tempo scale
/// - MIDI thru: you can play along with your MIDI instrument while the sequencer is playing
///
/// This class embeds many library objects: a MIDISequencer (with its MIDIMultiTrack) for
/// storing MIDI data, a MIDIDriver to communicate with hardware MIDI ports, a MIDIManager for
/// handling sequencer playing, some MIDIProcessor for thru transposing, rechannelizing, etc.
///
class AdvancedSequencer {
    public:


                            AdvancedSequencer(MIDISequencerGUINotifier *n = 0);
                            AdvancedSequencer(MIDIMultiTrack* mlt, MIDISequencerGUINotifier *n = 0);
                            AdvancedSequencer(MIDIManager* mg);
        virtual             ~AdvancedSequencer();


        MIDIThru*           GetMIDIThru()                   { return thru; }

        int                 GetMIDIThruChannel() const      { return thru_rechannelizer.GetRechanMap(0); }
        void                SetMIDIThruTranspose (int amt);
        int                 GetMIDIThruTranspose() const    { return thru_transposer.GetTransposeChannel(0); }

        bool                Load(const char *fname);
        void                UnLoad();
        void                Reset();
        bool                IsLoaded() const                { return file_loaded; }

        MIDIMultiTrack*     GetMultiTrack()                 { return multitrack; }
        const MIDIMultiTrack* GetMultiTrack() const         { return multitrack; }


        void                GoToZero()                      { GoToTime(0); }
        void                GoToMeasure(int measure, int beat = 0);
        void                GoToTime(MIDIClockTime t);

        void                Play();
        void                Stop();
        void                OutputMessage(MIDITimedMessage& msg, unsigned int port);

        void                SetRepeatPlay(bool f, int start_measure, int end_measure);
        bool                GetRepeatPlay() const           { return seq->GetRepeatPlay(); }
        int                 GetRepeatPlayStart() const      { return seq->GetRepeatPlayStart(); }
        int                 GetRepeatPlayEnd() const        { return seq->GetRepeatPlayEnd(); }
        bool                IsPlaying() const               { return MIDIManager::IsSeqPlay(); }

        void                SoloTrack(int trk);
        void                UnSoloTrack();
        bool                GetTrackSolo(int trk) const     { return seq->GetTrackProcessor (trk)->solo; }
        void                SetTrackMute(int trk, bool f);
        bool                GetTrackMute (int trk) const    { return seq->GetTrackProcessor (trk)->mute; }
        void                UnmuteAllTracks(void);
        void                SetTempoScale(double scale);
        double              GetTempoWithoutScale(void) const{ return seq->GetTempo(); }
        double              GetTempoWithScale(void) const   { return seq->GetTempo() * seq->GetTempoScale(); }

        /// Returns 'now' MIDI clock time.
        /// It is effective even during playback
        MIDIClockTime       GetCurrentMIDIClockTime() const;

        /// Returns 'now' time in milliseconds.
        /// When playing or jumping from one time to another, you can use this to feed a SMPTE
        tMsecs              GetCurrentTimeMs() const;

        /// Set MIDI ticks per beat (quarter note).
        /// \return **true** if clocks per beat are effectively changed
        /// \note  Currently the user is allowed to change this only when the sequencer is empty; default value is
        /// 120 clocks per quarter beat. However, LoadFile() can change this according to the file clock, and Unload()
        /// resets it to 120
        //bool                SetClksPerBeat ( unsigned int cpb );

        /// Returns the base MIDI ticks per beat of the internal MIDIMultiTrack. Default value is 120 clocks per
        /// quarter beat. However, LoadFile() can change this according to the file clock, and Unload()
        /// resets it to 120.
        int                 GetClksPerBeat() const              { return multitrack->GetClksPerBeat(); }

        /// Returns the number of tracks of the sequencer.
        int                 GetNumTracks() const                { return seq->GetNumTracks(); }

        /// Returns the number of measures of the sequencer.
        int                 GetNumMeasures() const              { return num_measures; }
        /// Returns the current measure number (first is 0).
        int                 GetCurrentMeasure() const;
        /// Returns the number of current beat (first is 0).
        int                 GetCurrentBeat() const;
        /// Returns the current MIDI time offset respect current beat.
        int                 GetCurrentBeatOffset() const;
        /// Returns the numerator of current time signature.
        int                 GetTimeSigNumerator() const;
        /// Returns the denominator of current time signature.
        int                 GetTimeSigDenominator() const;

        int                 GetKeySigSharpFlat() const;
        int                 GetKeySigMode() const;

        /// Sets the output MIDI port for the given track.
        void                SetTrackOutPort(int trk, unsigned int port);
        /// Returns the output MIDI port for the given track.
        int                 GetTrackOutPort(int trk) const    { return seq->GetTrackPort(trk); }

        int                 GetTrackNoteCount(int trk) const;
        /// Returns the name of the given track.
        std::string         GetTrackName(int trk) const;
        /// Returns the current MIDI volume for the given track (-1 if volume wasn't set).
        char                GetTrackVolume(int trk) const;          // MIDI value or -1
        /// Returns the current MIDI program (patch) for the given track (-1 if the program wasn't set).
        char                GetTrackProgram ( int trk ) const;      // MIDI value or -1
        void                SetTrackVelocityScale(int trk, double scale);
        double              GetTrackVelocityScale(int trk) const;
        void                SetTrackRechannelize(int trk, int chan);
        int                 GetTrackRechannelize(int trk) const;
        int                 GetTrackChannel(int trk) const;
        void                SetTrackTranspose(int trk, int trans);
        int                 GetTrackTranspose(int trk) const;
        void                SetTrackTimeShift(int trk, int time);
        int                 GetTrackTimeShift(int trk) const;
        std::string         GetCurrentMarker() const;

        void                SetSMPTE(SMPTE* s);

        void                SetChanged();
        /// Converts a MIDI clock time into milliseconds from the beginning of the song,
        /// taking into account tempo changes. You can use calculated time to feed a SMPTE.
        double              MIDItoMs(MIDIClockTime t) { return seq->MIDItoMs(t); }

    protected:

        static const int                    MEASURES_PER_WARP = 4;

        void                                ExtractWarpPositions();
        void                                CatchEventsBefore();
        void                                CatchEventsBefore(int trk);
        static void                         AutoStopProc(void* p);

        MIDIMultiTrack*                     multitrack;     ///< The sequencer multitrack
        MIDISequencer*                      seq;            ///< The sequencer
        //MIDIManager*                        mgr;            ///< The MIDIManager for playing
        MIDIThru*                           thru;           ///> The MIDI thru

        MIDIMultiProcessor                  thru_processor; ///< Processes incoming MIDI messages for MIDI thru
        MIDIProcessorTransposer             thru_transposer;///< Transposes note messages while playing
        MIDIProcessorRechannelizer          thru_rechannelizer;
                                                            ///< Rechannelize messages while playing

        int                                 num_measures;   ///< Number of measures
        bool                                file_loaded;    ///< True if the multitrack is not empty

        std::vector<MIDISequencerState>     warp_positions; ///< Vector of MIDISequencerState objects for fast time moving

private:

        enum { CTOR_1, CTOR_2, CTOR_3 };
        int ctor_type;
};
*/

#endif // JDKSMIDI_ADVANCEDSEQUENCER_H

/*
 *  libjdksmidi-2004 C++ Class Library for MIDI
 *
 *  Copyright (C) 2004  J.D. Koftinoff Software, Ltd.
 *  www.jdkoftinoff.com
 *  jeffk@jdkoftinoff.com
 *
 *  *** RELEASED UNDER THE GNU GENERAL PUBLIC LICENSE (GPL) April 27, 2004 ***
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
/*
** Copyright 1986 to 1998 By J.D. Koftinoff Software, Ltd.
**
** All rights reserved.
**
** No one may duplicate this source code in any form for any reason
** without the written permission given by J.D. Koftinoff Software, Ltd.
**
*/

//
// MODIFIED by N. Cassetta ncassetta@tiscali.it
//

/*
#ifndef JDKSMIDI_ADVANCEDSEQUENCER_H
#define JDKSMIDI_ADVANCEDSEQUENCER_H

#include "world.h"
#include "midi.h"
#include "msg.h"
#include "sysex.h"
#include "multitrack.h"
#include "filereadmultitrack.h"
#include "sequencer.h"
#include "manager.h"
#include "driver.h"


#ifdef _WIN32
#include "driverwin32.h"
#else
#include "driverdump.h"
#endif // _WIN32



#include <vector>

// #define MAX_WARP_POSITIONS (128)
// #define MEASURES_PER_WARP (4)    NC this is now a static const class attribute


///
/// A high level, all-in-one object capable to load an play MIDI files.
/// Its features include:
/// - Loading of MIDI files with a single call to a class method
/// - Play, Repeat Play (i.e. loop) and Stop commands
/// - Allows jumping from one time to another (even during playback) with correct responding
/// to wheel, patch, controls and sysex changes
/// - Individual solo, mute, velocity scale, transpose and rechannelize for every track
/// - Global tempo scale
/// - MIDI thru: you can play along with your MIDI instrument while the sequencer is playing
///
/// This class embeds many jdksmidi objects: a MIDISequencer (with its MIDIMultiTrack) for
/// storing MIDI data, a MIDIDriver to communicate with hardware MIDI ports, a MIDIManager for
/// handling sequencer playing, some MIDIProcessor for transposing, rechannelizing, etc.
/// At current time, the class can manage MIDI playback only on WIN32; for other OS it prints to
/// the console a dump of sent messages.
///

class AdvancedSequencer
{
public:





    /// Returns 'now' MIDI clock time.
    /// It is effective even during playback
    unsigned long GetCurrentMIDIClockTime() const; / * NEW BY NC * /

    /// Returns 'now' time in milliseconds.
    /// When playing or jumping from one time to another, you can use this to feed a SMPTE
    unsigned long GetCurrentTimeInMs() const; / * NEW BY NC * /

    /// Set MIDI ticks per beat (quarter note).
    /// \return **true** if clocks per beat are effectively changed
    /// \note  Currently the user is allowed to change this only when the sequencer is empty; default value is
    /// 120 clocks per quarter beat. However, LoadFile() can change this according to the file clock, and Unload()
    /// resets it to 120
    bool SetClksPerBeat ( unsigned int cpb );

    /// Returns the base MIDI ticks per beat of the internal MIDIMultiTrack
    int GetClksPerBeat() const  / * NEW BY NC * /
    {
        return tracks->GetClksPerBeat();
    }



protected:

    bool file_loaded;                   ///< true if the MIDIMultiTrack is not empty
    / * NOTE by NC: I mantained this name, but its meaning is now different:
     * it is nonzero if tracks is nonempty (maybe by an user editing)
     * /



};



#endif // JDKSMIDI_ADVANCEDSEQUENCER_H
*/
